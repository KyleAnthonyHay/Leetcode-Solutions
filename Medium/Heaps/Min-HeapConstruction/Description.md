# Min-Heap Construction

## Description

![description](./desc.png)

## Solution

There are 6 functions to write in order to complete this problem. We will go over them one at a time and draw a conclusion summarizing our combined algorithms.

### peek()

```py
def peek(self):
    return self.heap[0]
```

The peek function simply returns the root element (first element) of the heap array. This would be the first index. Keep in mind that since this is a Min-Heap the root will always be the smallest value.

### siftUp()

```py
# O(logn) time | O(1) Space
def siftUp(self,  currentIdx, heap):
    parentIdx = (currentIdx - 1) // 2
    while currentIdx > 0 and heap[currentIdx] < heap[parentIdx]:
        self.swap(currentIdx, parentIdx, heap)
        currentIdx = parentIdx
        parentIdx = (currentIdx - 1) // 2
```

`self` - .. <br>
`currentIdx` - initially a leaf node and represents the currently viewed node <br>
`heap` - the heap array <br>

This function is used when inserting values in the heep. It starts from a leave node, and shifts the value up a layer if that current value is smaller than its parent. We can calculate the parent node using the equation: `(currentIdx - 1) // 2`. The **while loop** continues until the `currentIdx` reaches the root node(0) or if the `currentIdx`'s value is _larger_ than its **parent** (in this case we wouldnt need to swap since it is now in the correct position). <br>

Remember, in a **Min-heap**, the parent is always smaller than the children.

### siftDown()

```py
# O(logn) time | O(1) Space
def siftDown(self, currentIdx, endIdx, heap):
    leftIdx = currentIdx * 2 + 1
    while leftIdx <= endIdx:
        rightIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1
        if rightIdx != -1 and heap[rightIdx] < heap[leftIdx]:
            idxToSwap = rightIdx
        else:
            idxToSwap = leftIdx

        if heap[idxToSwap] < heap[currentIdx]:
            self.swap(currentIdx, idxToSwap, heap)
            currentIdx = idxToSwap
            leftIdx = currentIdx * 2 + 1
        else:
            break
```

`self` - .. <br>
`currentIdx` - initially the **root** node and represents the currently viewed node <br>
`endIdx` - the last index in the array | the last leaf node<br>
`heap` - the heap array <br>

This function is used to remove items from the heap. It starts from the root node, and shifts values down a layer if the current node's value is larger than smallest of its two children. We can calculate the left and right children using the equations: `leftIdx = currentIdx * 2 + 1` and `rightIdx = currentIdx * 2 + 2`. <br>

The **while loop** continues until the `leftIdx` is greater than the `endIdx` (goes past the last leaf/index). Inside the loop, we apply our formula to find the rightIdx and assign it to the variable `rightIdx` only if it doest surpass the last index in the heap(endIdx).

## Explanation

**Time: O(n) For _building_ the `heap`** <br/>
**Space: O(1) since all operations are done in place**<br/>

1. Create a dictionary, `chars`, to store the number of character occurences in the `characters` string.

```py
chars = {}
```

The plan is to iterate through the input string `character`. At each point, we count how many times we see each character in the string. If we see a character for the first time, then we initialize the count as 1: `chars[char] = 1`, otherwise we increment the count by one: `chars[char] += 1`.

```py
for char in characters:
    if char not in chars:
        chars[char] = 1
    else:
        chars[char] += 1
```

2. Now, we iterate through the document string. At each point, we check if the currently observed character `char` exists in the dictionary. If it does, we decrement the count by one: `chars[char] -= 1`. If it doesn't exist, then we return `False`.

We also check if the count is 0. This is because the count = 0 indicates that we have used up all the avaliable character of that type. To illustate this, let's say we have two input strings:

```py
characters = "aabb"
document = "aabbb" # This string cannot be generated by "characters"
```

After the first for loop terminates, char["b"] = 2. And in the second for loop, when the index approaches the first two b's in the `document` string, char["b"] will be decremented by 1 two times. By the third time: `chars[char] == 0` would return True.

```py
    for char in document:
        if char not in chars or chars[char] == 0:
            return False
        else:
            chars[char] -= 1
```

Finally, if we have reached the end of the second for loop without terminating, we know we can generate the string in the `document` using the chars in `characters`

```py
return True
```

And we're **Done**!
